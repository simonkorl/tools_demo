'''
parse raw client, aitrans_server logs generated by AItransDTP tests
'''
import os
import pandas as pd
import re
import argparse

BACKUP_BASE_PATH = "./baselines_bk"
CLIENT_LOG_PATTERN = re.compile(r'connection closed, recv=(-?\d+) sent=(-?\d+) lost=(-?\d+) rtt=(?:(?:(\d|.+)ms)|(?:(-1))) cwnd=(-?\d+), total_bytes=(-?\d+), complete_bytes=(-?\d+), good_bytes=(-?\d+), total_time=(-?\d+)')
CLIENT_STAT_INDEXES = ["c_recv", "c_sent", "c_lost", "c_rtt(ms)", "c_cwnd", "c_total_bytes", "c_complete_bytes", "c_good_bytes", "c_total_time(us)", "qoe", "retry_times"]
CLIENT_BLOCKS_INDEXES = ["BlockID", "bct", "BlockSize", "Priority", "Deadline"]

PARAM_INDEXES = ["s_bw", "s_loss", "s_latency", "c_bw", "c_loss" ,"c_latency", "rtt", "type"]
SERVER_QOS_PATTERN = re.compile(r'total_bytes=(\d+), total_time\(us\)=(\d+), throughput\(B/s\)=(\d+)')
SERVER_DTP_PATTERN = re.compile(r'\d+: connection closed, recv=(\d+) sent=(\d+) lost=(\d+) rtt=(\d+)ns cwnd=(\d+)')
SERVER_STATS_INDEXES = ["s_recv", "s_sent", "s_lost", "s_rtt(ms)", "s_cwnd", "s_total_bytes", "s_total_time(us)", "s_through_put(B/s)"]
DIRNAME_PARSE_PATTERN = re.compile(r'sbw(\d|.+)_cbw(\d|.+)_loss(\d|.+)_rtt(\d+)_(\d+)')

# Type
TYPE_AITRANS_DTP = 0
TYPE_TCP = 1
 
def parse_client_log(dir_path, client_blocks_dict, client_stat_dict):
    with open(os.path.join(dir_path, "client.log")) as client:
        client_lines = client.readlines()
        
        for line in client_lines[4:-1]:
            if len(line) > 1:
               client_line_list = line.split() 
               if len(client_line_list) != len(CLIENT_BLOCKS_INDEXES):
                   print("A client block log line has error format in : %s" % dir_path)
                   continue
               for i in range(len(client_line_list)):
                   client_blocks_dict[CLIENT_BLOCKS_INDEXES[i]].append(client_line_list[i])
        # client_block_frame = pd.DataFrame(client_blocks_dict)
        # client_block_frame.to_csv(os.path.join(dir_path, "client_block.csv"), index=False)
        
        
        # try to parse the last line of client log
        try:
            match = CLIENT_LOG_PATTERN.match(client_lines[-1])
            if match == None:
                raise ValueError("client re match returns None in : %s" % dir_path, client_lines[-1])

            
        
            client_stat_dict["c_recv"].append(float(match.group(1)))
            client_stat_dict["c_sent"].append(float(match.group(2)))
            client_stat_dict["c_lost"].append(float(match.group(3))) 

            if match.group(4) is None:
               client_stat_dict["c_rtt(ms)"].append(float(-1))
            else:
               client_stat_dict["c_rtt(ms)"].append(float(match.group(4)))

            client_stat_dict["c_cwnd"].append(float(match.group(6)))
            client_stat_dict["c_total_bytes"].append(float(match.group(7)))
            client_stat_dict["c_complete_bytes"].append(float(match.group(8)))
            client_stat_dict["c_good_bytes"].append(float(9))
            client_stat_dict["c_total_time(us)"].append(float(match.group(10)))

            with open(os.path.join(dir_path, "qoe.log")) as qf:
                qoe = float(qf.readline())
            
                client_stat_dict["qoe"].append(qoe)

                # client_stat_frame = pd.DataFrame(client_stat_dict)
                # client_stat_frame.to_csv(os.path.join(dir_path, "client_stats.csv"), index=False)


            with open(os.path.join(dir_path, "retry.log")) as rf:
                retry_times = int(rf.readline())

                client_stat_dict["retry_times"].append(retry_times)

                return client_blocks_dict, client_stat_dict

        except Exception:
            print(dir_path)
            print(client_lines[-1])
            if match is not None:
                print(match.groups())
            raise ValueError("Could not parse client's last line")

def parse_server_log(dir_path, server_stats_dict, server_error_list):
    with open(os.path.join(dir_path, "server_aitrans.log")) as server:
        server_lines = server.readlines()
        
        if not server_lines[-1].startswith("total"):
            # a server that is shutted down by shell command
            # we may have to re-run them, so add them into the list
            server_error_list.append(dir_path)
            for index in SERVER_STATS_INDEXES:
                server_stats_dict[index].append(-1)
            return server_stats_dict, server_error_list 
        else:
            # parse dtp infos
            if dir_path.endswith("1"):
                server_stats_dict["s_recv"].append(-1)
                server_stats_dict["s_sent"].append(-1)
                server_stats_dict["s_lost"].append(-1)
                server_stats_dict["s_rtt(ms)"].append(-1)
                server_stats_dict["s_cwnd"].append(-1)
            elif dir_path.endswith("0"):
                match = SERVER_DTP_PATTERN.match(server_lines[-3])
                if match is None:
                    raise ValueError("server re dtp pattern match returns None in : %s" % dir_path, server_lines[-3])
                server_stats_dict["s_recv"].append(match.group(1))
                server_stats_dict["s_sent"].append(match.group(2))
                server_stats_dict["s_lost"].append(match.group(3))
                server_stats_dict["s_rtt(ms)"].append(match.group(4))
                server_stats_dict["s_cwnd"].append(match.group(5))
            else:
                raise ValueError("dir path endswith neither 0 or 1")

            # parse QoS infos
            match = SERVER_QOS_PATTERN.match(server_lines[-1])
            if match is None:
                raise ValueError("server re qos pattern match returns None in : %s" % dir_path, server_lines[-1])
            server_stats_dict["s_total_bytes"].append(match.group(1))
            server_stats_dict["s_total_time(us)"].append(match.group(2))
            server_stats_dict["s_through_put(B/s)"].append(match.group(3))
            return server_stats_dict, server_error_list

        # server_stats_frame = pd.DataFrame(server_stats_dict)
        # server_stats_frame.to_csv(os.path.join(dir_path, "server_stats.csv"), index=False) 


if __name__ == '__main__':
    backup_dir_list = os.listdir(BACKUP_BASE_PATH)
    # collect client blocks information
    client_blocks_dict = {}
    for index in CLIENT_BLOCKS_INDEXES:
        client_blocks_dict[index] = []
    # collect client stats
    client_stat_dict = {}
    for index in CLIENT_STAT_INDEXES:
        client_stat_dict[index] = []
    # collect server stats
    server_stats_dict = {}
    for index in SERVER_STATS_INDEXES:
        server_stats_dict[index] = []
    # parameters dict
    param_dict = {}
    for index in PARAM_INDEXES:
        param_dict[index] = []

    for exp in backup_dir_list:
        exp_dir = os.path.join(BACKUP_BASE_PATH, exp)
        if(os.path.exists(os.path.join(exp_dir, exp + '.csv'))):
            continue
        else:
            results_path = os.path.join(exp_dir, "raw")
            exp_results = os.listdir(results_path)
            server_error_list = []
            for dir in exp_results:
                if dir.endswith('csv') or dir.endswith('log'):
                    continue
                # parse experiment parameters       
                match = DIRNAME_PARSE_PATTERN.match(dir)
                param_dict["s_bw"].append(float(match.group(1)))
                param_dict["s_loss"].append(float(match.group(3)))
                param_dict["s_latency"].append(float(match.group(4)) / 2)
                param_dict["c_bw"].append(float(match.group(2)))
                param_dict["c_loss"].append(float(match.group(3)))
                param_dict["c_latency"].append(float(match.group(4)) / 2)
                param_dict["rtt"].append(float(match.group(4)))
                param_dict["type"].append(int(match.group(5))) 

                dir_path = os.path.join(results_path, dir)
                # parse client
                parse_client_log(dir_path, client_blocks_dict, client_stat_dict)
                # parse server
                parse_server_log(dir_path, server_stats_dict, server_error_list)

            final_stats = {}
            final_stats.update(param_dict)
            final_stats.update(client_stat_dict)
            final_stats.update(server_stats_dict)

            final_stats_frame = pd.DataFrame(final_stats)
            final_stats_frame.to_csv(os.path.join(exp_dir, exp + '.csv'))
            
            with open(os.path.join(exp_dir, "server_error.log"), "w") as f:
                for dir_path in server_error_list:
                    f.write(dir_path)
                    f.write("\n")